let env {}
let prt_delay 5
let prt_delay_disabled 0
let sig_interrupt 0

let runtime_running 0
let key_press []

/ ====== evaluating ======
def expr
 let _expr $0
 let _original $0
 int _i $_expr
 jeq $_i $nil continue
 ret $_i
 #continue
 ife $_expr '[]'
  ret []
 fin
 ife $_expr '{}'
  ret {}
 fin
 pol $_expr _c1
 ife $_c1 '$'
  ife $_expr 'lastkey'
   pol $key_press _key
   ret $_key
  els
   get $env $_expr _val
   ret $_val
  fin
 fin
 / str is parsed as %str, due to conflict with single quote
 ife $_c1 '%'
  ret $_expr
 fin
 ret $_original
end

def eval_param
 let _line $0
 let _idx $1
 get $_line $_idx _val
 cal expr $_val
 ret $ret
end

/ ** main eval **
def runtime
 let _src $0
 let _args $1
 let env {}
 let runtime_running 1
 let key_press []
 let i 0
 ife $_args $nil
 els
  for _arg $_args
    put $env $i $_arg
    add i $i 1
  nxt
 fin
 let _p {}
 let _lbl {}
 cal parse_src $_src $_p $_lbl
 let _pc 0

 let sig_interrupt 0
 
 #eval
 jeq $sig_interrupt 1 eval_done
 get $_p $_pc _line
 jeq $_line $nil eval_done
 get $_line 0 _cmd
 
 ife $_cmd 'clr'
  cal eval_param $_line 1
  ife $ret $nil
   clr
  els
   clr $ret
  fin
 fin
 ife $_cmd 'prt'
  get $_line 1 _val
  cal expr $_val
  let _val $ret
  get $_line 2 _val2
  ife $prt_delay_disabled 0
   slp $prt_delay
  fin
  ife $_val2 $nil
   prt $_val
  els
   cal expr $_val2
   prt $_val $ret
  fin
 fin
 ife $_cmd 'let'
  get $_line 1 _var
  cal eval_param $_line 2
  put $env $_var $ret
 fin
 jeq $_cmd 'add' do_arithmetic
 jeq $_cmd 'sub' do_arithmetic
 jeq $_cmd 'mul' do_arithmetic
 jeq $_cmd 'div' do_arithmetic
 jeq $_cmd 'mod' do_arithmetic
 jmp non_arithmetic
  #do_arithmetic
  get $_line 1 _var
  cal eval_param $_line 2
  let _val1 $ret
  cal eval_param $_line 3
  let _val2 $ret
  ife $_cmd 'add'
   add _res $_val1 $_val2
  fin
  ife $_cmd 'sub'
   sub _res $_val1 $_val2
  fin
  ife $_cmd 'mul'
   mul _res $_val1 $_val2
  fin
  ife $_cmd 'div'
   div _res $_val1 $_val2
  fin
  ife $_cmd 'mod'
   mod _res $_val1 $_val2
  fin
  put $env $_var $_res
 #non_arithmetic
 ife $_cmd 'slp'
  cal eval_param $_line 1
  slp $ret
 fin
 ife $_cmd 'drw'
  cal eval_param $_line 1
  let _x $ret
  cal eval_param $_line 2
  let _y $ret
  cal eval_param $_line 3
  drw $_x $_y $ret
 fin
 ife $_cmd 'pxl'
  get $_line 1 _name
  cal eval_param $_line 2
  let _x $ret
  cal eval_param $_line 3
  let _y $ret
  pxl $_x $_y _val
  put $env $_name $_val
 fin
 ife $_cmd 'jmp'
  get $_line 1 _lbl_name
  get $_lbl $_lbl_name _pc
 fin

 jeq $_cmd 'jeq' do_cond_jump
 jeq $_cmd 'jne' do_cond_jump
 jeq $_cmd 'jgt' do_cond_jump
 jeq $_cmd 'jlt' do_cond_jump
 jmp non_cond_jump
 #do_cond_jump
  cal eval_param $_line 1
  let _v1 $ret
  cal eval_param $_line 2
  let _v2 $ret
  get $_line 3 _lbl_name
  ife $_cmd 'jeq'
    jne $_v1 $_v2 jeq_false
    get $_lbl $_lbl_name _pc
    #jeq_false
  fin
  ife $_cmd 'jne'
    jeq $_v1 $_v2 jne_false
    get $_lbl $_lbl_name _pc
    #jne_false
  fin
  ife $_cmd 'jgt'
    jgt $_v1 $_v2 jgt_true
    jmp jgt_false
    #jgt_true
    get $_lbl $_lbl_name _pc
    #jgt_false
  fin
  ife $_cmd 'jlt'
    jlt $_v1 $_v2 jlt_true
    jmp jlt_false
    #jlt_true
    get $_lbl $_lbl_name _pc
    #jlt_false
  fin
 #non_cond_jump

 ife $_cmd 'inp'
  get $_line 1 _var
  inp _val
  put $env $_var $_val
 fin
 ife $_cmd 'rnd'
  get $_line 1 _name
  cal eval_param $_line 2
  let _v1 $ret
  cal eval_param $_line 3
  let _v2 $ret
  rnd _r $_v1 $_v2
  put $env $_name $_r
 fin
 jeq $_cmd 'int' type_cmd
 jeq $_cmd 'str' type_cmd
 jeq $_cmd 'typ' type_cmd
 jmp not_type_cmd
 #type_cmd
 get $_line 1 _var
 cal eval_param $_line 2
 ife $_cmd 'int'
  int _val $ret
 fin
 ife $_cmd 'str'
  str _val $ret
 fin
 ife $_cmd 'typ'
  typ _val $ret
 fin
 put $env $_var $_val
 #not_type_cmd
 ife $_cmd 'tim'
  get $_line 1 _var
  get $_line 2 _time
  tim _val $_time
  put $env $_var $_val
 fin
 ife $_cmd 'len'
  cal eval_param $_line 1
  let _list $ret
  get $_line 2 _name
  len $_list _len
  put $env $_name $_len
 fin
 ife $_cmd 'pol'
  cal eval_param $_line 1
  let _list $ret
  get $_line 2 _name
  pol $_list _first
  get $_line 1 _list_name
  pol $_list_name x
  put $env $_list_name $_list
  put $env $_name $_first
 fin
 ife $_cmd 'pop'
  cal eval_param $_line 1
  let _list $ret
  get $_line 2 _name
  pop $_list _last
  get $_line 1 _list_name
  pol $_list_name x
  put $env $_list_name $_list
  put $env $_name $_last
 fin
 ife $_cmd 'psh'
  cal eval_param $_line 1
  let _list $ret
  len $_line _line_len
  sub _line_len $_line_len 2
  for i $_line_len
    add j $i 2
    cal eval_param $_line $j
    let _val $ret
    psh $_list $_val
  nxt
  get $_line 1 _list_name
  pol $_list_name x
  put $env $_list_name $_list
 fin
 ife $_cmd 'put'
  cal eval_param $_line 1
  let _map $ret
  cal eval_param $_line 2
  let _key $ret
  cal eval_param $_line 3
  let _val $ret
  put $_map $_key $_val
 fin
 ife $_cmd 'get'
  cal eval_param $_line 1
  let _list $ret
  cal eval_param $_line 2
  let _key $ret
  cal eval_param $_line 3
  let _var $ret
  get $_list $_key _val
  put $env $_var $_val
 fin
 
 / ** special **
 ife $_cmd 'led'
  cal eval_param $_line 1
  let _led_val $ret
  jeq $_led_val 0 valid_led_value
  jeq $_led_val 1 valid_led_value
  jmp led_done
  #valid_led_value
  cal set_led 2 $_led_val
  #led_done
 fin

 / ** system library **
 ife $_cmd 'lib'
  cal eval_param $_line 1
  let _lib_name $ret
  ife $_lib_name 'os.get_home_path'
   cal get_home_path
   get $_line 2 _name
   put $env $_name $ret
  fin
  ife $_lib_name 'os.get_current_path'
   cal lib_get_path
   get $_line 2 _name
   put $env $_name $ret
  fin
  ife $_lib_name 'os.set_current_path'
   cal eval_param $_line 2
   cal lib_set_path $ret
  fin
  ife $_lib_name 'os.delete_path'
   cal eval_param $_line 2
   cal lib_delete_path $ret
  fin
  ife $_lib_name 'os.make_dir'
   cal eval_param $_line 2
   let _path $ret
   cal eval_param $_line 3
   let _name $ret
   cal lib_make_dir $_path $_name
  fin
  ife $_lib_name 'os.get_file_list'
   cal eval_param $_line 2
   let _path $ret
   cal lib_get_file_list $_path
   get $_line 3 _name
   put $env $_name $ret
  fin
  ife $_lib_name 'os.get_file_type'
   cal eval_param $_line 2
   let _path $ret
   cal eval_param $_line 3
   let _file_name $ret
   cal lib_get_file_type $_path $_file_name
   get $_line 4 _file_type_name
   put $env $_file_type_name $ret
  fin
  ife $_lib_name 'os.read_file'
   cal eval_param $_line 2
   let _path $ret
   cal eval_param $_line 3
   let _file_name $ret
   cal lib_read_file $_path $_file_name
   get $_line 4 _file_content_name
   put $env $_file_content_name $ret
  fin
  ife $_lib_name 'os.write_file'
   cal eval_param $_line 2
   let _path $ret
   cal eval_param $_line 3
   let _file_name $ret
   cal eval_param $_line 4
   let _file_content $ret
   cal lib_write_file $_path $_file_name $_file_content
  fin
  ife $_lib_name 'os.get_os_info'
   get $_line 2 _info
   cal lib_get_os_info
   put $env $_info $ret
  fin
  ife $_lib_name 'os.get_sys_info'
   get $_line 2 _info
   cal lib_get_sys_info
   put $env $_info $ret
  fin
  ife $_lib_name 'util.get_path_by_str'
   cal eval_param $_line 2
   let _path_str $ret
   cal eval_param $_line 3
   let _is_file $ret
   cal get_path_by_str $_path_str $_is_file
   get $_line 4 _name
   put $env $_name $ret
  fin
  ife $_lib_name 'dev.set_led'
   cal eval_param $_line 2
   let _val $ret
   cal lib_set_led $_val
  fin
  ife $_lib_name 'term.prev_line'
   cal lib_screen_prev_line
  fin
  ife $_lib_name 'term.clear_line'
   cal lib_screen_clear_line
  fin
  ife $_lib_name 'term.set_prt_delay'
   cal eval_param $_line 2
   cal lib_set_prt_delay $ret
  fin
  ife $_lib_name 'term.get_width'
   get $_line 2 _name
   put $env $_name $term_w
  fin
  ife $_lib_name 'term.get_height'
   get $_line 2 _name
   put $env $_name $term_h
  fin
  ife $_lib_name 'term.move_cursor'
   cal eval_param $_line 2
   let _dx $ret
   cal eval_param $_line 3
   let _dy $ret
   ifg $_dx 0
    for _ $_dx
     cal lib_screen_right_arrow
    nxt
   els
    mul _ndx $_dx -1
    for _ $_ndx
     cal lib_screen_left_arrow
    nxt
   fin
   ifg $_dy 0
    for _ $_dy
     cal lib_screen_down_arrow
    nxt
   els
    mul _ndy $_dy -1
    for _ $_ndy
     cal lib_screen_up_arrow
    nxt
   fin
  fin
 fin

 add _pc $_pc 1
 jmp eval
 
 #eval_done
 let runtime_running 0
end
